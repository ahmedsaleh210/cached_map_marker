library cached_map_marker;

import 'dart:developer';
import 'dart:io';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';

part 'utils/cache_method.dart';
part 'utils/create_image_from_widget.dart';
part 'utils/image_processing.dart';

class CachedMapMarker {
  late final BaseCacheManager _instance;

  CachedMapMarker({BaseCacheManager? cacheManager})
      : _instance = cacheManager ?? DefaultCacheManager();

  /// Retrieves a cached network file, caching it if not already cached.
  ///
  /// This function attempts to retrieve a file from cache based on a network URL and specified dimensions. If the file is not found in the cache, it is downloaded from the network, resized to the specified dimensions, cached, and then returned.
  ///
  /// Parameters:
  /// - [url] : The URL of the network resource to be cached.
  /// - [width] : The desired width of the image. This is used to resize the image before caching it.
  /// - [height] : The desired height of the image. This is used in conjunction with the width to resize the image.
  ///
  /// Returns:
  /// A [Future] that completes with the [File] either retrieved from cache or newly cached after downloading and resizing.
  Future<File> _getCachedNeworkFile({
    required String url,
    required int width,
    required int height,
  }) async {
    try {
      final cacheKey = _extractCacheKey(url, width, height);
      File? file = await _getCachedFileFromMemoryOrHardDiskIfExist(
          url: url, cacheKey: cacheKey);
      file ??= await _CacheMethod.network(
        url: url,
        cacheKey: cacheKey,
        width: width,
        height: height,
        cacheManager: _instance,
      ).cache();
      return file;
    } catch (e) {
      rethrow;
    }
  }

  /// Retrieves a cached file from widget.
  ///
  /// Attempts to retrieve a file based on the given [cacheKey], [imageSize], [logicalSize], and
  /// [widget]. It first tries to find the file in the cache. If not found, it caches the
  /// provided bytes as a file, and then returns it.
  ///
  /// Throws an exception if the file cannot be retrieved or cached.
  ///
  /// Returns a [File] object representing the cached file.
  Future<File> _getCachedWidgetFile(
      {required String cacheKey,
      Size? logicalSize,
      Size? imageSize,
      Duration? waitToRender,
      required Widget widget}) async {
    try {
      File? file = await _getCachedFileFromMemoryOrHardDiskIfExist(
          url: cacheKey, cacheKey: cacheKey);
      file ??= await _CacheMethod.widget(
              cacheKey: cacheKey,
              cacheManager: _instance,
              widget: widget,
              imageSize: imageSize,
              logicalSize: logicalSize)
          .cache();
      return file;
    } catch (e) {
      rethrow;
    }
  }

  /// Checks for a cached file in memory or on disk.
  ///
  /// Tries to find a cached file using the provided [cacheKey]. It first checks the memory
  /// cache and then the disk cache.
  ///
  /// Returns a [File] object if found, otherwise null.
  Future<File?> _getCachedFileFromMemoryOrHardDiskIfExist({
    required String url,
    required String cacheKey,
  }) async {
    File? file = await _getFileFromMemoryCache(cacheKey);
    file ??= await _getFileFromDiskCache(cacheKey);
    return file;
  }

  /// Generates a cache key from a [URL], [width], and [height].
  ///
  /// The cache key is used to uniquely identify files in the cache. It is generated by
  /// removing query parameters from the URL and appending the [width] and [height].
  ///
  /// Returns a string representing the cache key.
  String _extractCacheKey(String url, int width, int height) =>
      '${url.split('?').first}-$width-$height';

  /// Attempts to retrieve the file from memory cache.
  Future<File?> _getFileFromMemoryCache(String cacheKey) async {
    final file = (await _instance.getFileFromMemory(cacheKey))?.file;
    if (file != null) {
      log('Cached Marker Logger: File retrieved from memory cache.');
    }
    return file;
  }

  /// Attempts to retrieve the file from disk cache.
  Future<File?> _getFileFromDiskCache(String cacheKey) async {
    final file = (await _instance.getFileFromCache(cacheKey))?.file;
    if (file != null) {
      log('Cached Marker Logger: File retrieved from disk cache.');
    }
    return file;
  }

  /// Creates a [BitmapDescriptor] from a network image.
  ///
  /// Downloads an image from the given [url] and caches it locally. The image is then
  /// converted into a [BitmapDescriptor] which can be used to represent markers on a map.
  ///
  /// The [width] and [height] parameters specify the size to which the image should be
  /// resized. If not specified, both default to 150 pixels.
  ///
  /// Throws an exception if the image cannot be downloaded or processed.
  ///
  /// Returns a [BitmapDescriptor] representing the downloaded image.
  Future<BitmapDescriptor> fromNetwork({
    required String url,
    Size size = const Size(70, 70),
  }) async {
    final file = await _getCachedNeworkFile(
      url: url,
      height: size.height.toInt(),
      width: size.width.toInt(),
    );
    final bytes = await file.readAsBytes();
    final descriptor = BitmapDescriptor.bytes(bytes);
    await delayFor15MilliSconds();
    return descriptor;
  }

  /// This function takes a widget and optionally its logical size and image size,
  /// renders it to an image, caches it, and then creates a [BitmapDescriptor] from the cached image.
  /// This is useful for dynamic content that needs to be displayed as a marker on a map, for example.
  ///
  /// Parameters:
  /// - [cacheKey]: A unique string to identify the cached file. This is required to retrieve or overwrite the cached image.
  /// - [widget]: The [Widget] to be rendered and cached. This is the content that will be converted into an image.
  /// - [waitToRender] (optional): A [Duration] to wait before rendering the widget. This can be useful if the widget needs some time to complete its build phase.
  /// - [logicalSize] (optional): The logical size of the widget in logical pixels. This can be used to define the size of the widget before rendering it.
  /// - [imageSize] (optional): The size of the image to be cached. This can differ from the logical size of the widget and is used when the rendered image needs to be of a specific size.
  ///
  /// Returns:
  /// A [Future] that completes with a [BitmapDescriptor] representing the rendered and cached widget.
  ///
  /// Note: This function includes a brief delay (15 milliseconds) after creating the bitmap descriptor to ensure that the file operations complete successfully.
  Future<BitmapDescriptor> fromWidget({
    required String cacheKey,
    required Widget widget,
    Duration? waitToRender,
    Size? logicalSize,
    Size? imageSize,
  }) async {
    final file = await _getCachedWidgetFile(
        cacheKey: cacheKey,
        widget: widget,
        waitToRender: waitToRender,
        logicalSize: logicalSize,
        imageSize: imageSize);
    final result = await file.readAsBytes();
    final descriptor = BitmapDescriptor.bytes(result);
    await delayFor15MilliSconds();
    return descriptor;
  }

  Future<void> delayFor15MilliSconds() async {
    await Future.delayed(const Duration(milliseconds: 15), () {});
  }

  Future<void> clearCache() async {
    await _instance.emptyCache();
    log('Cached Marker Logger: Cache cleared.');
  }
}
